document.addEventListener('DOMContentLoaded', () => {
    // --- 定数とDOM要素の取得 ---
    const canvas = document.getElementById('g-meter-canvas');
    const ctx = canvas.getContext('2d');
    const gDisplay = document.getElementById('g-display');
    const logElement = document.getElementById('log');
    const requestPermissionButton = document.getElementById('request-permission');
    const resetMaxGButton = document.getElementById('reset-max-g');
    const warningSound = document.getElementById('warning-sound');

    // 最大G表示DOM要素
    const maxGLeftElement = document.getElementById('max-g-left');
    const maxGRightElement = document.getElementById('max-g-right');
    const maxGForwardElement = document.getElementById('max-g-forward');
    const maxGBackwardElement = document.getElementById('max-g-backward');

    const METER_MAX_G = 0.7; // メーターの最大表示範囲 (G)
    const BALL_RADIUS = 8; // ボールの半径 (px)
    const TRACE_TIME_S = 3.0; // 残像の表示時間 (秒)
    const TRACE_POINTS_LIMIT = 300; // 残像の最大点数 (約3秒/10msで300点)
    const EMA_ALPHA = 0.3; // 指数移動平均の平滑化係数 (0〜1、小さいほど滑らか)

    // --- 状態変数 ---
    let gravityOffset = { x: 0, y: 0 }; // 初期化時の重力オフセット
    let isInitialized = false;
    let filteredG = { x: 0, y: 0 }; // フィルタ後のG
    let totalG = 0; // 合成G
    let tracePoints = []; // 残像の軌跡

    // 最大G記録
    let maxG = {
        left: 0,
        right: 0,
        forward: 0,
        backward: 0
    };

    // 警告音制御
    let peakG = 0;
    let warningCooldown = false; // 連続警告防止用フラグ

    // --- メーター描画関数 ---
    function drawMeter() {
        const size = canvas.width;
        const center = size / 2;
        const radius = size / 2;

        // Canvasをクリア
        ctx.clearRect(0, 0, size, size);

        // --- 1. 目盛りと十字線 (青: #007aff 系) ---
        ctx.strokeStyle = '#007aff';
        ctx.fillStyle = '#007aff';
        ctx.lineWidth = 1;
        ctx.setLineDash([]); // 実線に戻す

        // 十字線
        ctx.beginPath();
        ctx.moveTo(0, center);
        ctx.lineTo(size, center);
        ctx.moveTo(center, 0);
        ctx.lineTo(center, size);
        ctx.stroke();

        // 目盛り円 (0.3G, 0.6G) - 点線
        ctx.setLineDash([5, 5]);

        const r03 = radius * (0.3 / METER_MAX_G);
        ctx.beginPath();
        ctx.arc(center, center, r03, 0, 2 * Math.PI);
        ctx.stroke();

        const r06 = radius * (0.6 / METER_MAX_G);
        ctx.beginPath();
        ctx.arc(center, center, r06, 0, 2 * Math.PI);
        ctx.stroke();

        ctx.setLineDash([]); // 実線に戻す

        // --- 2. 凡例の数値表示 ---
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // 0.3G
        ctx.fillText('0.3G', center + r03 + 15, center);
        // 0.6G
        ctx.fillText('0.6G', center + r06 + 15, center);
        // 中央 (0G)
        ctx.fillText('0G', center, center + 20);

        // --- 3. 残像（トレース）の描画 (赤: rgba(255, 0, 0, 1.0)) ---
        const now = performance.now();
        const maxTraceLife = TRACE_TIME_S * 1000;

        // 古い点を削除
        while (tracePoints.length > 0 && now - tracePoints[0].timestamp > maxTraceLife) {
            tracePoints.shift();
        }

        // 残像を描画
        tracePoints.forEach(point => {
            const lifeRatio = (now - point.timestamp) / maxTraceLife; // 0 (最新) -> 1 (最古)
            const alpha = 1.0 - lifeRatio; // 1.0 -> 0.0 でフェードアウト

            ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
            ctx.beginPath();
            ctx.arc(point.x, point.y, 2, 0, 2 * Math.PI); // 小さな点
            ctx.fill();
        });

        // --- 4. ボール（現在のG）の描画 (白: white) ---
        // Gをピクセル座標に変換
        const pixelX = filteredG.x * (radius / METER_MAX_G); // 横方向 (X軸、デバイス右が+X)
        const pixelY = -filteredG.y * (radius / METER_MAX_G); // 前後方向 (Y軸、デバイス前が+Y)

        // 合成Gが最大Gを超えないように制限
        const distance = Math.sqrt(pixelX * pixelX + pixelY * pixelY);
        let drawX = center + pixelX;
        let drawY = center + pixelY;

        if (distance > radius) {
            const ratio = radius / distance;
            drawX = center + pixelX * ratio;
            drawY = center + pixelY * ratio;
        }

        // ボールを描画
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(drawX, drawY, BALL_RADIUS, 0, 2 * Math.PI);
        ctx.fill();

        // 残像に現在の点を追加
        tracePoints.push({
            x: drawX,
            y: drawY,
            timestamp: now
        });
        if (tracePoints.length > TRACE_POINTS_LIMIT) {
            tracePoints.shift();
        }

        // --- 5. 合成G値の表示 ---
        gDisplay.textContent = `${totalG.toFixed(2)} G`;
    }

    // Canvasサイズを調整 (CSSで設定したサイズに合わせる)
    function resizeCanvas() {
        const size = canvas.offsetWidth;
        canvas.width = size;
        canvas.height = size;
        drawMeter(); // リサイズ後に再描画
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // --- センサー処理 ---
    function handleDeviceMotion(event) {
        if (!isInitialized) return;

        const acc = event.accelerationIncludingGravity;
        if (!acc || acc.x === null) {
            logElement.textContent = 'ログ: DeviceMotionEventのデータが不完全です。';
            return;
        }

        // Gを算出 (加速度-オフセット)
        // 進行方向 (車体Y軸, デバイスの縦) の加速度 = acc.y
        // 横方向 (車体X軸, デバイスの横) の加速度 = acc.x
        // 重力加速度 (m/s^2) で割って G に変換 (9.80665 m/s^2)
        const gX = (acc.x - gravityOffset.x) / 9.80665; // 横G
        const gY = (acc.y - gravityOffset.y) / 9.80665; // 前後G

        // --- フィルタリング (EMA) ---
        filteredG.x = (gX * EMA_ALPHA) + (filteredG.x * (1 - EMA_ALPHA));
        filteredG.y = (gY * EMA_ALPHA) + (filteredG.y * (1 - EMA_ALPHA));

        // 合成Gの計算
        totalG = Math.sqrt(filteredG.x * filteredG.x + filteredG.y * filteredG.y);

        // --- 最大G記録の更新 (4方向独立) ---
        // X軸: 左方向 (+X) / 右方向 (-X)
        if (filteredG.x > 0) { // 左方向
            maxG.left = Math.max(maxG.left, filteredG.x);
        } else { // 右方向 (符号を反転して絶対値で記録)
            maxG.right = Math.max(maxG.right, Math.abs(filteredG.x));
        }

        // Y軸: 前方向 (+Y, 加速) / 後方向 (-Y, 減速)
        if (filteredG.y > 0) { // 前方向 (加速)
            maxG.forward = Math.max(maxG.forward, filteredG.y);
        } else { // 後方向 (減速/ブレーキ, 符号を反転して絶対値で記録)
            maxG.backward = Math.max(maxG.backward, Math.abs(filteredG.y));
        }

        updateMaxGDisplay();

        // --- 警告音処理 ---
        checkWarning(totalG);

        // --- 描画 ---
        drawMeter();
    }

    function updateMaxGDisplay() {
        maxGLeftElement.textContent = maxG.left.toFixed(2);
        maxGRightElement.textContent = maxG.right.toFixed(2);
        maxGForwardElement.textContent = maxG.forward.toFixed(2);
        maxGBackwardElement.textContent = maxG.backward.toFixed(2);
    }

    function checkWarning(currentG) {
        // 閾値: ピークGが 0.4G以上
        if (peakG >= 0.4) {
            // スリップ条件: ピークGより 0.3G以上低下
            if (currentG < peakG - 0.3) {
                if (!warningCooldown) {
                    playWarningSound();
                    warningCooldown = true;
                    // 警告音のクールダウン (例: 1秒間は再警告しない)
                    setTimeout(() => { warningCooldown = false; }, 1000);
                }
                // ピークGをリセットして次のピークを待つ
                peakG = 0;
            }
        }

        // ピークGを更新
        peakG = Math.max(peakG, currentG);
    }

    function playWarningSound() {
        // warningSound が有効なソースを持つ場合のみ再生
        if (warningSound.readyState >= 2) {
            warningSound.currentTime = 0; // 最初から再生
            warningSound.play().catch(e => {
                // 自動再生ポリシーなどで失敗した場合の処理
                logElement.textContent = 'ログ: 警告音の再生に失敗しました。' + e;
            });
        }
        logElement.textContent = `ログ: スリップ警告音を再生しました！ (G: ${totalG.toFixed(2)})`;
    }

    // --- イベントハンドラ ---
    requestPermissionButton.addEventListener('click', () => {
        // iOS 13+ で必要な DeviceMotion の許可リクエスト
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
            DeviceMotionEvent.requestPermission().then(permissionState => {
                if (permissionState === 'granted') {
                    startMotionTracking();
                } else {
                    logElement.textContent = 'ログ: センサーの使用が拒否されました。';
                }
            }).catch(error => {
                logElement.textContent = 'ログ: センサー許可リクエスト中にエラーが発生しました。' + error;
            });
        } else {
            // Android, PCなど、許可が不要な環境
            startMotionTracking();
        }
    });

    function startMotionTracking() {
        window.addEventListener('devicemotion', initializeZeroPoint, { once: true });
        logElement.textContent = 'ログ: センサーデータを取得し、初期化しています...';
    }

    function initializeZeroPoint(event) {
        const acc = event.accelerationIncludingGravity;
        if (!acc || acc.x === null) {
            logElement.textContent = 'ログ: DeviceMotionEventのデータが不完全なため、初期化できませんでした。';
            return;
        }

        // この時点の重力成分をオフセットとして記録
        gravityOffset.x = acc.x;
        gravityOffset.y = acc.y;
        isInitialized = true;
        
        // フィルタ後のGも初期化 (0G)
        filteredG.x = 0;
        filteredG.y = 0;

        window.removeEventListener('devicemotion', initializeZeroPoint);
        window.addEventListener('devicemotion', handleDeviceMotion);
        
        // 警告音再生のためのユーザーインタラクション確保 (ミュートで一度再生)
        warningSound.volume = 0;
        warningSound.play().catch(() => {});
        warningSound.volume = 1;

        logElement.textContent = `ログ: センサー初期化完了。X: ${gravityOffset.x.toFixed(2)} m/s², Y: ${gravityOffset.y.toFixed(2)} m/s² をゼロ点に設定しました。`;
    }
    
    resetMaxGButton.addEventListener('click', () => {
        maxG = { left: 0, right: 0, forward: 0, backward: 0 };
        updateMaxGDisplay();
        logElement.textContent = 'ログ: 最大G記録をリセットしました。';
    });
});
